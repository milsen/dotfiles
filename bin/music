#!/bin/bash --
#
# "$HOME"/bin/music by milsen
#
# A script to update and show information about my music collection.
#

# Get important file paths.
source "$XDG_CONFIG_HOME"/user-dirs.dirs
MUSIC_DIR=${XDG_MUSIC_DIR:-$HOME/music}
OWNED_ALBUMS_FILE="$HOME/doc/Listen/albums.txt"
WISHLIST_FILE="$HOME/doc/Listen/wishlist.md"

usage() {
  cat <<EOF
  usage: $(basename $0) [OPTIONS]

    Input:
      -o        operate on owned albums in $OWNED_ALBUMS_FILE
      -w        operate on albums in wishlist $WISHLIST_FILE
      -a        operate on all albums (short for -ow)
      -n [arg]  operate on the given album name

    Input Manipulation (the last option given supercedes the previous ones):
      -f        select album(s) from the input using fzf
      -g [arg]  select album(s) from the input using grep [arg]
      -r        select a random album from the input

    Input-Independent Actions:
      -e        edit the wishlist in $WISHLIST_FILE
      -u        update list of owned albums in $OWNED_ALBUMS_FILE

    Album Actions (these force selecting a single album):
      -i        get info about album
      -p        play album with mpc (if not owned via youtube-dl)
      -x        copy album name to the X clipboard
EOF
}

append_albums() {
  list="$list $(cat "$1" | grep "^-")"
}

fzf_select() {
  fzf --multi
  # --preview='source <<EOF
  # cover_preview() {
  #   # get the file with the cover art (jpg or png)
  #   cover_dir="$music_dir"/"$(echo "$1" | cut -d " " -f "2-" | sed 's# / #/#')"
  #   cover_file="$(find "$cover_dir" -regex '.*cover\.\(jpg\|png\)' | head -n 1)"
  #   if [ -r "$cover_file" ]; then
  #     feh -q -^ "cover art" --zoom fill -g "300x300+1600+50}" "$cover_file" \
  #       /dev/null 2>&1 &
  #   fi
  # }
# EOF
  # ; cover_preview {+1}' \
  # --preview-window hidden
}

play_last_in_playlist() {
  # Call with $1 being one of mpc's %format strings%.
  # Current playlist (prepend _ in case of no album name)
  PLAYLIST=$(mpc playlist --format "%${1:-album}%" | awk -F'\n' '{print "_" $1}')

  # Get number of songs in playlist, last item.
  LAST_POS="$(echo "$PLAYLIST" | wc -l)"
  LAST_ALBUM="$(echo "$PLAYLIST" | tail -n 1)"

  # Go backwards from last position until the item name changes.
  for (( IDX=$LAST_POS; $IDX >= 0; IDX-- )); do
    if [ $IDX == 0 ]; then
      mpc -q play 1
    elif [ "$(echo "$PLAYLIST" | sed "${IDX}q;d")" != "$LAST_ALBUM" ]; then
      let IDX+=1
      mpc -q play $IDX
      break
    fi
  done
}

select_item() {
  # If only one item is specified, use it, else select one with fzf.
  if [ "$(echo "$1" | wc -l)" -eq 1 ]; then
    echo "$1"
  else
    echo "$1" | fzf
  fi
}

update_album_list() {
  find "$MUSIC_DIR" -maxdepth 2 -mindepth 2 -type d \
      -printf "- %h / %f\n" | \
      sed 's#'"$MUSIC_DIR"'/##' > "$OWNED_ALBUMS_FILE" \
      && echo "$OWNED_ALBUMS_FILE was updated."
}

# Exit if an important file is not found/readable.
if [ ! -r "$OWNED_ALBUMS_FILE" ]; then
  echo "$OWNED_ALBUMS_FILE not found." && exit 1
elif [ ! -r "$WISHLIST_FILE" ]; then
  echo "$WISHLIST_FILE not found." && exit 1
fi

# Get options.
while getopts ":aefg:in:opruwx" opt; do
  case $opt in
    a) append_albums "$OWNED_ALBUMS_FILE"
       append_albums "$WISHLIST_FILE" ;;
    e) ${EDITOR:-nvim} +"normal Go- " +"startinsert!" "$WISHLIST_FILE" ;;
    f) input_processing=fzf ;;
    g) input_processing=grep; grep_keyword=$OPTARG ;;
    i) info=1 ;;
    n) list="$(echo -e "- $OPTARG\n$list")" ;;
    o) append_albums "$OWNED_ALBUMS_FILE" ;;
    p) play=1 ;;
    r) input_processing=random ;;
    u) update_album_list "$OPTARG" ;;
    w) append_albums "$WISHLIST_FILE" ;;
    x) copy=1 ;;
    *) usage && exit ;;
  esac
done
shift $((OPTIND - 1))

# if no album is specified so far, use the owned ones as a default.
if [ -z "$list" ]; then
  append_albums "$OWNED_ALBUMS_FILE"
fi

# Sort the list and remove duplicates.
list="$(echo "$list" | sort | uniq)"

# Input processing.
case $input_processing in
  fzf)    list="$(echo "$list" | fzf_select)"              ;;
  grep)   list="$(echo "$list" | grep -- "$grep_keyword")" ;;
  random) list="$(echo "$list" | sort -R | head -n 1)"     ;;
esac

# Select single album if neccessary for action option.
# Echo selected album(s) afterwards.
if [ -n "$copy" ] || [ -n "$play" ] || [ -n "$info" ]; then
  album="$(select_item "$list")"
  echo "$album"
  album="$(echo "$album" | cut -d " " -f "2-" )"
else
  echo "$list"
fi

# Copy the album name into the clipboard.
if [ -n "$copy" ]; then
  echo "$album" | xsel -ib
fi

# Play the album using mpc.
if [ -n "$play" ]; then
  # If the album is owned, play it directly with mpc.
  if [ -n "$(grep -- "$album" "$OWNED_ALBUMS_FILE")" ]; then
    dir="$(grep -- "$album" "$OWNED_ALBUMS_FILE" | \
      cut -d " " -f "2-" | sed 's# / #/#')"
    mpc ls "$dir" | mpc -q add
    play_last_in_playlist album
  else
    # Else play the album using a stream found via youtube-dl.
    search_term="$(echo "$album" | sed 's# / # #') full"

    url="$(youtube-dl --get-url --format 140 gvsearch1:"$search_term")" && {
      # youtube-dl --skip-download --write-thumbnail gvsearch1:"$search_term"
      mpc -q add "$url"
      play_last_in_playlist file
    }
  fi
  notify-send "Now playing \"$album\"."
fi

# Get info on RYM about the album.
if [ -n "$info" ]; then
  qutebrowser \
    ":open -p http://rateyourmusic.com/search?searchtype=l&searchterm=$album"
fi

exit $?

